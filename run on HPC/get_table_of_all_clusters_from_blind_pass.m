function [base_table_of_all_clusters] = get_table_of_all_clusters_from_blind_pass(config)
% a default config file can be generated by the function blank_config.m
% please ensure that all of the file paths are correctly set before running this, or else this function may behave unexpectedly
% if you are working on a simulated dataset your next step after this should be to use add_max_overlap_col(table_of_all_clusters,config)
%add_max_overlap_col
% table_of_all_clusters = [];



if config.ON_HPC
    gen_grades_dir = config.GENERIC_GRADES_DIR_ON_HPC;
    gen_output_dir = config.GENERIC_GRADES_DIR_ON_HPC;
    gen_results_dir = config.GENRIC_DIR_WITH_OUTPUTS_ON_HPC;
else
    gen_grades_dir = config.GENERIC_GRADES_DIR;
    gen_output_dir = config.GENERIC_GRADES_DIR;
    gen_results_dir =config.GENRIC_DIR_WITH_OUTPUTS ; %this is not an error
    %in the config struct I mixed up the output/results dir
    %it would be too much work to go back and fix it in every file so it's smarter to just leave it as is
    %and account for it
    %you'll know the directories are correct if the results dir has "t* aligned.mat", "t* output.mat", "t* reg_timestamps.mat" files
    %the output dir should have files labeled "t*.mat"
end
z_scores_to_access = config.DEFAULT_CLUSTERING_Z_SCORES;
art_tetr_array = config.ART_TETR_ARRAY;
ordered_list_of_tetrodes = strcat("t",string(1:size(art_tetr_array,1)));

table_of_all_clusters_cell_array = cell(size(z_scores_to_access,2),1);
for i=1:size(z_scores_to_access,2)
    curr_z_sc = z_scores_to_access(i);
    grades_dir = fullfile(gen_grades_dir+" "+string(curr_z_sc)+" grades");
    results_dir = fullfile(gen_results_dir+string(curr_z_sc));
    output_dir = fullfile(gen_output_dir+string(curr_z_sc));


    %get the files with all the data that will be needed from the blind pass
    list_of_output_files = struct2table(dir(output_dir));
    list_of_grades_files = struct2table(dir(grades_dir));
    list_of_results_files = struct2table(dir(results_dir));

    %slice the tables so that we can run the process getting the data in parallel
    relevant_rows = cell(size(ordered_list_of_tetrodes,2),1);
    for j=1:size(ordered_list_of_tetrodes,2)
        curr_tetr = ordered_list_of_tetrodes(j);
        aligned_string = curr_tetr+" aligned.mat";
        output_string = curr_tetr +" output.mat";
        reg_timestamps_string = curr_tetr+" reg_timestamps_of_spikes.mat" ;
        grades_string = curr_tetr+" Grades.mat";
        gen_tetr_string = curr_tetr+".mat";

        [output_row,~] = find(string(list_of_results_files{:,"name"})==output_string);
        [aligned_row,~] = find(string(list_of_results_files{:,"name"})==aligned_string);
        [reg_timstamp_row,~] = find(string(list_of_results_files{:,"name"})==reg_timestamps_string);
        [grades_row,~] = find(string(list_of_grades_files{:,"name"})==grades_string);
        [gen_row,~] = find(string(list_of_output_files{:,"name"})==gen_tetr_string);

        if all([size(output_row,1),size(aligned_row,1),size(reg_timstamp_row,1),size(grades_row,1),size(gen_row,1)]==0)
            continue; %indicates that this tetrode did not finish for one reason or another
        end
        if ~all([size(output_row,1),size(aligned_row,1),size(reg_timstamp_row,1),size(grades_row,1),size(gen_row,1)]==1)
            disp("get_table_of_all_clusters_from_blind_pass.m Failed to get "+curr_tetr)
            disp("output rows")
            display(output_row);
            disp("aligned rows");
            display(aligned_row);
            disp("reg_timestamp_rows");
            display(reg_timestamp_rows);
            disp("grades row");
            display(grades_row);
            disp("gen row");
            display(gen_row)
            continue;
        end
        %first element of relevant rows is the file path of "t* output.mat"
        %second element ... is ... "t* aligned.mat"
        %third element ... is ... "t* reg_timestamps_of_spikes.mat"
        %fourth element ... is ... "t* Grades.mat"
        %fifth element ... is ... "t*.mat"
        relevant_rows{j} = {list_of_results_files(output_row,:),list_of_results_files(aligned_row,:),list_of_results_files(reg_timstamp_row,:),list_of_grades_files(grades_row,:),list_of_output_files(gen_row,:)};
    end

    table_of_all_clusters_for_current_z_score = cell2table(cell(0,9), ...
        'VariableNames', ...
        ["Z Score","Tetrode","Cluster","grades","dir_to_output","dir_to_aligned","dir_to_ts","dir_to_grades","dir_to_r_tvals"]);
    if config.IS_PARALLEL_AVAILABLE && config.USE_PARALLEL
        parfor j=1:size(ordered_list_of_tetrodes,2)
            current_rows = add_fps_z_score_cluster_tetrode_grades_to_rows(ordered_list_of_tetrodes,j,relevant_rows,curr_z_sc);
            table_of_all_clusters_for_current_z_score = [table_of_all_clusters_for_current_z_score;current_rows];
        end
    else
        for j=1:size(ordered_list_of_tetrodes,2)
            current_rows = add_fps_z_score_cluster_tetrode_grades_to_rows(ordered_list_of_tetrodes,j,relevant_rows,curr_z_sc);
            table_of_all_clusters_for_current_z_score = [table_of_all_clusters_for_current_z_score;current_rows];
        end
    end
    table_of_all_clusters_cell_array{i} = table_of_all_clusters_for_current_z_score;




end
disp("get_table_of_all_clusters_from_blind_pass.m Finished");
base_table_of_all_clusters = vertcat(table_of_all_clusters_cell_array{:});

end