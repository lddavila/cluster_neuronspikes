function [next_observation,reward,is_done,next_state] = custom_step_function(action,state)

%define environment constants
if config.ON_HPC
    parent_save_dir = config.parent_save_dir_ON_HPC;
    blind_pass_table = importdata(config.FP_TO_TABLE_OF_ALL_BP_CLUSTERS_ON_HPC);
    presorted_table = importdata(fullfile(config.parent_save_dir,config.config.DIR_TO_SAVE_RESULTS_TO,"presorted_table.mat"));
else
    parent_save_dir = config.parent_save_dir;
    blind_pass_table = importdata(config.FP_TO_TABLE_OF_ALL_BP_CLUSTERS);
    presorted_table = importdata(fullfile(config.parent_save_dir_ON_HPC,config.config.DIR_TO_SAVE_RESULTS_TO,"presorted_table.mat"));
end

[grade_names,all_grades]= flatten_grades_cell_array(blind_pass_table{:,"grades"},config);
[indexes_of_grades_were_looking_for,~] = find(ismember(grade_names,config.NAMES_OF_CURR_GRADES(config.GRADE_IDXS_THAT_ARE_USED_TO_PICK_BEST)));
grades_array = all_grades(:,indexes_of_grades_were_looking_for);

%get only the grads of the enviornment
grade_locs_for_presorted = nan(size(presorted_table,1),1);
for i=1:size(presorted_table,1)
    c1 = blind_pass_table{:,"Z Score"}==presorted_table{i,"Z Score"};
    c2 = blind_pass_table{:,"Tetrode"}==presorted_table{i,"Tetrode"};
    c3 = blind_pass_table{:,"Cluster"}==presorted_table{i,"Cluster"};
    [grade_locs_for_presorted(i),~] =find(c1 & c2 & c3);
end

all_possible_grades = [grades_array(grade_locs_for_presorted,:),repmat(state(19:end),size(presorted_table,1),1)];

%determine where the current step is in the process
[loc_of_current_step,~] = find(ismember(state,all_possible_grades,"rows"));

%now get the ACTUAL accuracy of the current state
[original_loc_in_bp_table,~] = find(ismember(state(19:end),grades_array,"rows"));
true_accuracy = blind_pass_table{original_loc_in_bp_table,"accuracy"};

%define 2 terminal states (can't move down anymore)/have reached true accuracy
[~,terminal_state_1_index]= min(abs(true_accuracy-presorted_table{:,"accuracy"}));
terminal_state_2_index= 100;

%check if you have reached the terminal condition
if action==0 && loc_of_current_step==terminal_state_1_index
    reward = 10; %stopping at the correct location invokes a reward of 10
elseif action==1 && loc_of_current_step+1>terminal_state_1_index
    reward = -10; %moving past the correct state invokes a penalty of -10
                  %moving past the correct state should invoke a steeper penalty to avoid over estimation
elseif action==0 && loc_of_current_step ~= terminal_state_1_index
    reward = -10; %staying on the correct location invokes a penalty of -10
elseif action==1 && loc_of_current_step ~= terminal_state_1_index
    reward = -1; %movement in general invokes a penalty of -1
end

%check to see if moving down is possible 
%it's only ever not possible when your at the bottom of the table
if action==1 && loc_of_current_step==terminal_state_2_index
    error("Must stay a")

%now define the reward/punishment based on the true accuracy
if action ==0
    next_state = state;
else
    next_state = all_possible_grades(loc_of_current_step+1,:);
end

next_observation = next_state;


end